# openapi-db

A lightweight, framework-agnostic library that serves REST API endpoints directly from an OpenAPI spec with SQL queries embedded via a custom `x-db` extension.

## Philosophy

- **Pure JavaScript/TypeScript.** No framework dependencies.
- **Takes Node's `IncomingMessage`.** Works with raw `http.createServer`, Express, Fastify, Hono - anything.
- **Returns plain objects.** The library never sends responses. It returns `{ status, headers, body }` or `null`. You decide how to send.
- **Throws typed errors.** You decide how to format error responses to match your schema.
- **Does its own routing.** OpenAPI routing semantics differ from Express/Fastify, so we match routes ourselves and return `null` for non-matches.

## Core API

```typescript
import { IncomingMessage } from "http";
import { Pool } from "pg";

// Factory function
function createRouter(options: RouterOptions): Promise<Router>;

interface RouterOptions {
  // Path to OpenAPI spec file (YAML or JSON), or pre-parsed object
  spec: string | OpenAPIDocument;

  // Postgres connection pool
  db: Pool;

  // Optional auth resolver - called for routes that use $auth.*
  auth?: (req: IncomingMessage) => Promise<Record<string, unknown> | null>;
}

interface Router {
  // Handle a request. Returns null if no matching x-db route.
  handle(req: IncomingMessage): Promise<Response | null>;
}

interface Response {
  status: number;
  headers?: Record<string, string>;
  body: unknown;
}
```

## The `x-db` Extension

Operations in the OpenAPI spec can include an `x-db` extension:

```yaml
x-db:
  # Raw SQL query with variable interpolation - required
  query: string

  # Response shaping - optional
  response:
    # 'array' (default) - return all rows as array
    # 'first' - return first row as object, or null if no rows
    # 'value' - return first column of first row as scalar
    type: 'array' | 'first' | 'value'

    # Field mapping: API field name -> SQL column name
    fields:
      apiFieldName: sql_column_name
```

## Variable Syntax

Variables in SQL queries are replaced with parameterised placeholders (safe from SQL injection):

```
$path.paramName           # URL path parameters
$query.paramName          # Query string parameters
$body.field.nested.path   # Request body with nested access
$body                     # Entire request body (for JSONB columns etc)
$auth.fieldName           # From auth resolver return value
```

## Function Syntax

Helper functions for common operations:

```
$.default(value, fallback)    # Returns fallback if value is null/undefined
$.now()                       # Current timestamp as Date
$.uuid()                      # Generate UUID v4
```

Functions can be nested: `$.default($query.status, 'active')`

## Example OpenAPI Spec

```yaml
openapi: 3.0.3
info:
  title: Users API
  version: 1.0.0

paths:
  /users:
    get:
      operationId: listUsers
      parameters:
        - name: status
          in: query
          schema:
            type: string
        - name: limit
          in: query
          schema:
            type: integer
      x-db:
        query: |
          SELECT id, first_name, last_name, email, created_at
          FROM users
          WHERE tenant_id = $auth.tenantId
            AND status = $.default($query.status, 'active')
          ORDER BY created_at DESC
          LIMIT $.default($query.limit, 20)
        response:
          fields:
            firstName: first_name
            lastName: last_name
            createdAt: created_at

    post:
      operationId: createUser
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                firstName:
                  type: string
                lastName:
                  type: string
                email:
                  type: string
      x-db:
        query: |
          INSERT INTO users (id, first_name, last_name, email, tenant_id, created_at)
          VALUES ($.uuid(), $body.firstName, $body.lastName, $body.email, $auth.tenantId, $.now())
          RETURNING id, first_name, last_name, email, created_at
        response:
          type: first
          fields:
            firstName: first_name
            lastName: last_name
            createdAt: created_at

  /users/{id}:
    get:
      operationId: getUser
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      x-db:
        query: |
          SELECT id, first_name, last_name, email, created_at
          FROM users
          WHERE id = $path.id AND tenant_id = $auth.tenantId
        response:
          type: first
          fields:
            firstName: first_name
            lastName: last_name
            createdAt: created_at

    delete:
      operationId: deleteUser
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
      x-db:
        query: |
          DELETE FROM users
          WHERE id = $path.id AND tenant_id = $auth.tenantId
          RETURNING id
        response:
          type: first

  /stats/user-count:
    get:
      operationId: getUserCount
      x-db:
        query: |
          SELECT COUNT(*)::int FROM users WHERE tenant_id = $auth.tenantId
        response:
          type: value
```

## Usage Examples

### Raw Node.js

```typescript
import http from "http";
import { Pool } from "pg";
import { createRouter } from "openapi-db";

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

const router = await createRouter({
  spec: "./openapi.yaml",
  db: pool,
  auth: async (req) => {
    const token = req.headers.authorization?.split(" ")[1];
    if (!token) return null;
    const user = await verifyJwt(token);
    return { userId: user.id, tenantId: user.tenantId };
  },
});

http
  .createServer(async (req, res) => {
    try {
      const response = await router.handle(req);

      if (!response) {
        res.writeHead(404, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Not found" }));
        return;
      }

      res.writeHead(response.status, {
        "Content-Type": "application/json",
        ...response.headers,
      });
      res.end(JSON.stringify(response.body));
    } catch (err) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Internal server error" }));
    }
  })
  .listen(3000);
```

### Express

```typescript
import express from "express";
import { Pool } from "pg";
import { createRouter, OpenApiDbError } from "openapi-db";

const app = express();
app.use(express.json());

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const router = await createRouter({ spec: "./openapi.yaml", db: pool });

app.use(async (req, res, next) => {
  try {
    const response = await router.handle(req);
    if (!response) return next();
    res.status(response.status).json(response.body);
  } catch (err) {
    if (err instanceof OpenApiDbError) {
      res.status(err.status).json({ error: err.code, message: err.message });
    } else {
      next(err);
    }
  }
});

// Custom routes work normally
app.get("/health", (req, res) => res.json({ ok: true }));

app.listen(3000);
```

### Fastify

```typescript
import Fastify from "fastify";
import { Pool } from "pg";
import { createRouter, OpenApiDbError } from "openapi-db";

const fastify = Fastify();
const pool = new Pool({ connectionString: process.env.DATABASE_URL });
const router = await createRouter({ spec: "./openapi.yaml", db: pool });

fastify.addHook("onRequest", async (req, reply) => {
  try {
    const response = await router.handle(req.raw);
    if (response) {
      reply.status(response.status).send(response.body);
    }
  } catch (err) {
    if (err instanceof OpenApiDbError) {
      reply.status(err.status).send({ error: err.code, message: err.message });
    } else {
      throw err;
    }
  }
});

fastify.get("/health", async () => ({ ok: true }));

fastify.listen({ port: 3000 });
```

## Architecture

```
createRouter(options)
        │
        ▼
┌───────────────────────────────────────────┐
│           Boot-time Setup                 │
├───────────────────────────────────────────┤
│  1. Parse OpenAPI spec (YAML/JSON)        │
│  2. Extract operations with x-db          │
│  3. Build route matching table            │
│  4. Validate $auth usage vs auth option   │
│  5. Validate $path/$query vs OpenAPI spec │
└───────────────────────────────────────────┘
        │
        ▼
     Router
        │
        ▼
router.handle(req: IncomingMessage)
        │
        ▼
┌───────────────────────────────────────────┐
│           Request Handling                │
├───────────────────────────────────────────┤
│  1. Parse body/query if not already done  │
│  2. Match request to OpenAPI route        │
│  3. Return null if no match               │
│  4. Call auth() if route uses $auth.*     │
│  5. Build context (path, query, body, auth)│
│  6. Interpolate SQL template              │
│  7. Execute parameterised query           │
│  8. Shape response (fields, type)         │
│  9. Return { status, headers, body }      │
└───────────────────────────────────────────┘
```

## Project Structure

```
openapi-db/
├── src/
│   ├── index.ts              # Public exports
│   ├── router.ts             # createRouter factory, Router class
│   ├── matcher.ts            # OpenAPI route matching
│   ├── parser.ts             # OpenAPI spec parsing, x-db extraction
│   ├── template.ts           # SQL template parsing and interpolation
│   ├── executor.ts           # Query execution
│   ├── response.ts           # Response shaping
│   ├── errors.ts             # Error classes
│   └── types.ts              # TypeScript interfaces
├── test/
│   ├── router.test.ts
│   ├── matcher.test.ts
│   ├── template.test.ts
│   ├── executor.test.ts
│   └── fixtures/
│       └── openapi.yaml
├── package.json
├── tsconfig.json
└── README.md
```

## Implementation Details

### Request Handling

The `handle()` method receives Node's `IncomingMessage`. Frameworks like Express and Fastify extend this with pre-parsed `body` and `query`. Detect and use those, or parse ourselves:

```typescript
async handle(req: IncomingMessage): Promise<Response | null> {
  // Use pre-parsed values if available (Express/Fastify add these)
  const body = (req as any).body ?? await this.parseBody(req);
  const query = (req as any).query ?? this.parseQuery(req.url);

  const method = req.method?.toLowerCase() ?? 'get';
  const path = this.parsePath(req.url);

  // Match against OpenAPI routes with x-db
  const match = this.matchRoute(method, path);
  if (!match) return null;

  // Resolve auth if needed
  let auth: Record<string, unknown> | null = null;
  if (match.usesAuth) {
    if (!this.options.auth) {
      throw new OpenApiDbError('AUTH_RESOLVER_MISSING', 'Route uses $auth but no auth resolver provided', 500);
    }
    auth = await this.options.auth(req);
    if (!auth) {
      throw new OpenApiDbError('AUTH_REQUIRED', 'Authentication required', 401);
    }
  }

  // Build context
  const context = {
    path: match.pathParams,
    query,
    body,
    auth,
  };

  // Interpolate and execute
  const { sql, values } = this.interpolate(match.xDb.query, context);
  const rows = await this.execute(sql, values);

  // Shape response
  const responseBody = this.shapeResponse(rows, match.xDb.response);

  return {
    status: 200,
    headers: { 'Content-Type': 'application/json' },
    body: responseBody,
  };
}
```

### Route Matching

Implement OpenAPI-style route matching:

```typescript
interface RouteMatch {
  operation: OpenAPIOperation;
  xDb: XDbExtension;
  pathParams: Record<string, string>;
  usesAuth: boolean;
}

// At boot time, compile routes into matchers
interface CompiledRoute {
  method: string;
  pattern: RegExp;
  paramNames: string[];
  operation: OpenAPIOperation;
  xDb: XDbExtension;
  usesAuth: boolean;
}

// Convert /users/{id}/posts/{postId} to regex with named groups
function compileRoute(
  method: string,
  path: string,
  operation: OpenAPIOperation
): CompiledRoute {
  const paramNames: string[] = [];
  const pattern = path.replace(/{(\w+)}/g, (_, name) => {
    paramNames.push(name);
    return "([^/]+)";
  });

  const xDb = operation["x-db"];
  const usesAuth = /\$auth\.\w+/.test(xDb.query);

  return {
    method,
    pattern: new RegExp(`^${pattern}$`),
    paramNames,
    operation,
    xDb,
    usesAuth,
  };
}

function matchRoute(method: string, path: string): RouteMatch | null {
  for (const route of this.compiledRoutes) {
    if (route.method !== method) continue;

    const match = path.match(route.pattern);
    if (!match) continue;

    const pathParams: Record<string, string> = {};
    route.paramNames.forEach((name, i) => {
      pathParams[name] = match[i + 1];
    });

    return {
      operation: route.operation,
      xDb: route.xDb,
      pathParams,
      usesAuth: route.usesAuth,
    };
  }

  return null;
}
```

### Template Interpolation

Parse SQL templates, extract variables and functions, produce parameterised query:

```typescript
interface InterpolationResult {
  sql: string; // SQL with $1, $2, $3... placeholders
  values: unknown[]; // Corresponding values
}

function interpolate(template: string, context: Context): InterpolationResult {
  const values: unknown[] = [];
  let paramIndex = 0;

  // Regex to match $path.x, $query.x, $body.x.y.z, $auth.x, $.func(...)
  const sql = template.replace(
    /\$(\w+)(?:\.(\w+(?:\.\w+)*))?|\$\.(\w+)\(([^)]*)\)/g,
    (match, prefix, path, funcName, funcArgs) => {
      let value: unknown;

      if (funcName) {
        // Function call: $.default(...), $.now(), $.uuid()
        value = evaluateFunction(funcName, funcArgs, context);
      } else if (prefix === "path") {
        value = context.path[path];
      } else if (prefix === "query") {
        value = context.query[path];
      } else if (prefix === "body") {
        value = path ? getNestedValue(context.body, path) : context.body;
      } else if (prefix === "auth") {
        value = context.auth?.[path];
      } else {
        throw new OpenApiDbError(
          "INVALID_VARIABLE",
          `Unknown variable: ${match}`,
          500
        );
      }

      values.push(value);
      return `$${++paramIndex}`;
    }
  );

  return { sql, values };
}

function evaluateFunction(
  name: string,
  argsStr: string,
  context: Context
): unknown {
  switch (name) {
    case "default": {
      // Parse args - could be nested: $.default($query.status, 'active')
      const [valueExpr, fallbackExpr] = parseArgs(argsStr);
      const value = evaluateExpression(valueExpr, context);
      const fallback = evaluateExpression(fallbackExpr, context);
      return value ?? fallback;
    }
    case "now":
      return new Date();
    case "uuid":
      return crypto.randomUUID();
    default:
      throw new OpenApiDbError(
        "UNKNOWN_FUNCTION",
        `Unknown function: $.${name}()`,
        500
      );
  }
}

function getNestedValue(obj: unknown, path: string): unknown {
  return path.split(".").reduce((acc, key) => (acc as any)?.[key], obj);
}
```

### Array Query Parameters

Detect array parameters from OpenAPI spec and coerce:

```yaml
parameters:
  - name: ids
    in: query
    schema:
      type: array
      items:
        type: string
```

If the spec says `ids` is an array, split the query string value:

```typescript
// ?ids=1,2,3 becomes ['1', '2', '3']
function parseQueryWithSpec(
  url: string,
  parameters: OpenAPIParameter[]
): Record<string, unknown> {
  const parsed = new URL(url, "http://localhost").searchParams;
  const result: Record<string, unknown> = {};

  for (const [key, value] of parsed.entries()) {
    const param = parameters.find((p) => p.name === key && p.in === "query");

    if (param?.schema?.type === "array") {
      // Coerce to array based on style (default: form with explode: true means comma-separated)
      result[key] = value.split(",");
    } else {
      result[key] = value;
    }
  }

  return result;
}
```

### Response Shaping

Apply field mapping and type conversion after query:

```typescript
interface XDbResponse {
  type?: "array" | "first" | "value";
  fields?: Record<string, string>;
}

function shapeResponse(
  rows: Record<string, unknown>[],
  config?: XDbResponse
): unknown {
  // Apply field mapping
  const mapped = rows.map((row) => {
    if (!config?.fields) return row;

    const result: Record<string, unknown> = {};
    for (const [apiField, dbColumn] of Object.entries(config.fields)) {
      result[apiField] = row[dbColumn];
    }
    // Include unmapped fields as-is
    for (const [key, value] of Object.entries(row)) {
      if (!Object.values(config.fields).includes(key)) {
        result[key] = value;
      }
    }
    return result;
  });

  // Apply type transformation
  switch (config?.type) {
    case "first":
      return mapped[0] ?? null;
    case "value":
      if (!mapped[0]) return null;
      const firstRow = mapped[0];
      const firstKey = Object.keys(firstRow)[0];
      return firstRow[firstKey];
    default:
      return mapped;
  }
}
```

### Error Handling

Typed errors for users to catch and format:

```typescript
export class OpenApiDbError extends Error {
  constructor(
    public code: string,
    message: string,
    public status: number = 500,
    public details?: unknown
  ) {
    super(message);
    this.name = "OpenApiDbError";
  }
}

// Error codes:
// 'SPEC_PARSE_ERROR'      - Failed to parse OpenAPI spec
// 'VALIDATION_ERROR'      - Boot-time validation failed
// 'AUTH_RESOLVER_MISSING' - Route uses $auth but no auth option provided
// 'AUTH_REQUIRED'         - Auth resolver returned null
// 'INVALID_VARIABLE'      - Unknown variable syntax in template
// 'UNKNOWN_FUNCTION'      - Unknown function in template
// 'QUERY_ERROR'           - Database query failed
```

### Boot-time Validation

When `createRouter()` is called:

1. **Parse spec** - YAML or JSON, resolve $refs
2. **Extract x-db routes** - Filter to operations that have x-db extension
3. **Compile routes** - Convert paths to regex matchers
4. **Validate auth usage** - If any query uses `$auth.*` but no `auth` option provided, throw
5. **Validate path params** - If query references `$path.foo` but `foo` isn't in the path, warn
6. **Validate query params** - If query references `$query.bar` but `bar` isn't in parameters, warn

```typescript
export async function createRouter(options: RouterOptions): Promise<Router> {
  // Parse spec
  const spec =
    typeof options.spec === "string"
      ? await parseSpecFile(options.spec)
      : options.spec;

  // Extract and compile routes
  const compiledRoutes: CompiledRoute[] = [];

  for (const [path, pathItem] of Object.entries(spec.paths ?? {})) {
    for (const method of ["get", "post", "put", "patch", "delete"] as const) {
      const operation = pathItem[method];
      if (!operation?.["x-db"]) continue;

      const route = compileRoute(method, path, operation);

      // Validate auth usage
      if (route.usesAuth && !options.auth) {
        throw new OpenApiDbError(
          "VALIDATION_ERROR",
          `Route ${method.toUpperCase()} ${path} uses $auth but no auth resolver provided`
        );
      }

      compiledRoutes.push(route);
    }
  }

  return new Router(compiledRoutes, options);
}
```

## Dependencies

Minimal:

- `yaml` - Parse YAML specs
- `pg` - Postgres driver

Use Node built-ins for everything else (`crypto`, `url`).

## Testing

Write tests for:

1. **Route matching** - Path patterns, parameter extraction, method matching
2. **Template interpolation** - All variable types, nested body access, all functions, nesting
3. **Response shaping** - Field mapping, all type modes, edge cases
4. **Boot-time validation** - Auth checking, param validation errors
5. **Integration tests** - Full request → response with test database

Provide `docker-compose.yml` for local Postgres:

```yaml
version: "3.8"
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: test
      POSTGRES_PASSWORD: test
      POSTGRES_DB: openapi_db_test
    ports:
      - "5432:5432"
```

## Scope

**In scope:**

- `createRouter()` factory returning `Router` with `handle()` method
- OpenAPI 3.x spec parsing (YAML and JSON)
- `x-db` extension with `query`, `response.type`, `response.fields`
- Variable interpolation: `$path.*`, `$query.*`, `$body.*` (nested), `$auth.*`
- Functions: `$.default()`, `$.now()`, `$.uuid()`
- OpenAPI route matching
- Postgres adapter
- Boot-time validation
- Array query parameter coercion
- Typed errors

**Out of scope:**

- Framework-specific adapter packages (just show usage patterns in docs)
- Request validation against OpenAPI schemas
- Response validation
- Multiple database connections
- Other database adapters
- Additional functions
- Content-type negotiation (assume JSON)
